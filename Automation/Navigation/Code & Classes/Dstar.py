# NECESSARY PACKAGES 
from Grid import Grid    # Importing the Grid Class from Grid.py

import numpy as np       # Numpy to so a numpy 2D array can be used for the grid

import math             # necessary to get the math functions needed to calculate the distance

import heapq            # used to create a min heap

"""
Class: DstarKinda

ATTRIBUTES: 
   List neighborIndex:      List of tuples that will be used to calculate the indexes of the neighbors of a cell
   Grid mapGrid:            Stores 2D numpy array that represents the grid tht will be traversed
   int Xsize:               Size of row
   int Ysize:               Size of Column 
   List finalPath:          list containing tuples that is the final path generated by the algorithm
   float finalWeight        the max weight any wait can have before being marked as non traversable     

METHODS:
    __init__(X,Y):              constructor by entering the X and Y dimesions
    __init__(Grid):             constroctor by using the dimension of premade numpy array
    getMap():                   returns the numpy grip map
    addHazardtoMap():           recieves a coordinate tuple and marks the corresponding cell as a hazard
    addSinglehazard():          adds single hazard to the path
    distance():                 calculates the distance between two sets of coordinates 
    smallestNeighbordistance(): determines which neighboring cell is the smallest distance to the end point
    isSamepoint():              checks if two coordinate tuples entered are the same
    isOutofBound():             checks if the tuple coordinate is out of bounds of the grid
    isTraversable():            returns true or false based on if the tuple of coordinates can be considered for the final path
    generatePath():             runs algorithm to generate the the path between two points 
    cleanPath():                takes the inital path generate and cleans it to make it more optimal 
    placePathonMap():           takes the final path and represents it on the grip             

PACKAGES:

    From Grid import Grid:      The grid that the algorithm will use to generate the path
    import numpy as np :        used to create and utilize the fuctions of a numpy array
    import math:                used to get the neccessary math functions
    import heapq:               used to implement a min heap

DESCRIPTION:
    This class is used implement our pathplanning algorithm. This is a greedy algorithm 
    that uses heuristic descion making at each step. This is done by calculating the distance 
    between each neighbor of the current location and the end point and setting that value 
    as the weight of that cell, throwing out any neighbors that are out of bound, a hazard or 
    weight is higher than the max allowed weight (the distance between the start and end + 2).
    The algorthm then picks the neighbor with the smallest weight and sets that as the new location
    , repeating that step until an inital path is acheived. This inital path is then cleaned by removing
    all duplicates while maintaining the order of the points and slicing if the start point is not at the 
    start of the path, then performing the same process again but now only considering the points that 
    remain in the initial path to gain a close to optimal path. This algorithm is inspired by the D* lite 
    and A* pathplanning algorithm 

"""

class DstarKinda:
    # stores the tuples that will be used to add and subtract from the current positon to obtain the neighbor indexes 
    neighbor_index = [(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0)]
    
    """
    Name: __init__ (X,Y)
    
    INPUT: 
        X:  Size of rows
        Y:  Size of columns 
    
    RETURN: 
        N/A
    
    DESCRIPTION:
        Constructor that creates grid in environment the size X*Y that will be used 
        to plan the path 
    """
    def __init__(self,X,Y):
        # creating numpy array of size X*Y
        self.Map_Grid = np.zeros((X,Y), dtype = float)
        
        # getting the dimensions of the grid
        self.X_size = self.Map_Grid.shape[0]
        self.Y_size = self.Map_Grid.shape[1]
        
        #storing the final path 
        self.Final_path = []
        # storing the max allowed weight of a cell 
        self.Final_weight = 7
    """
    Name: __init__ (Grid)
    
    INPUT: 
       Grid:    Grid object created from Grid class 
    
    RETURN: 
        N/A
    
    DESCRIPTION:
        Constructor that creates grid in environment the size of the dimensions of the 
        grid passed in from the grid function 
    """
    def __init__(self, Grid:Grid):
        
        # creating the grid to match the size of the grid created by the Grid class
        self.Map_Grid = Grid.getMatrix()
        
        # getting the grid dimensions
        self.X_size = self.Map_Grid.shape[0]
        self.Y_size = self.Map_Grid.shape[1]
        
        #storing the final path
        self.Final_path = []
        # storing the max allowed weight of a cell
        self.Final_weight = 7
    """
    Name: getMap()
    
    INPUT: 
      N/A
    
    RETURN: 
        Grid: the grid that is being traversed
    
    DESCRIPTION:
        Return the grid that is being traversed and all the wieghts being calculated 
    """
    def getMap(self):
        return self.Map_Grid
    """
    Name: addHazardtoMap()
    
    INPUT: 
      Hazard_list:  list of tuples representing coordinates  
    
    RETURN: 
        N/A
    
    DESCRIPTION:
        Sets cells that correspond with the coordinates of hazards to -1 as a way 
        to represent a hazard
    """
    def addHazardtoMap(self,Hazard_list:list[tuple[int,int]]):
        # traversing list of hazard location to update the grid
        for hazards in Hazard_list:
            # update the grid
            self.Map_Grid[hazards[0]][hazards[1]] = -1
    """
    Name: addSinglehazard()
    
    INPUT: 
      Hazard:   tuple representing coordinates  
    
    RETURN: 
        N/A
    
    DESCRIPTION:
        Adds a single hazard tuple to the map
    """        
    def addSinglehazard(self,Hazard:tuple[int,int]):
        self.Map_Grid[Hazard[0]][Hazard[1]] = -1
    """
    Name: distance()
    
    INPUT: 
      current:  tuple containing the current location
      end:      tuple containing the end location
    
    RETURN: 
        Float:  the final calculation using the distance formula
    
    DESCRIPTION:
        uses the distance formula to calculate the distance between the current point 
        and the end point
    """ 
    def distance(self,current: tuple, end: tuple):
        return math.sqrt((end[0]-current[0])**2 + (end[1]-current[1])**2)
    
    """
    Name: smallestNeighbordistance()
    
    INPUT: 
      current:  tuple containing the current location
      end:      tuple containing the end location
    
    RETURN: 
      smallest:    tuple that represents the neighbor that is found to be the smallest distance from the end
    
    DESCRIPTION:
        calculates the distance between each neighbor of the current point and sets that locations weight on the grid
        (throwing out any neighbors that are not traversable). then selecting the neighbor with the smaller weight and 
        then incrementing that weight by 1.
    """ 
    def smallestNeighborsdistance(self,current:tuple,end:tuple):#, max_x, max_y, min_x, min_y)
        distances = []
        heap =[]
        # obtaining the coordinates for all neighbors 
        for indexes in self.neighbor_index:
            # calculating neighbor coordinates 
            neighbor = (current[0]+indexes[0],current[1]+indexes[1])
            
            # checking if neighbor is traversable
            if self.isTraversable(neighbor):
                # if the neighbor already has a weight skip 
                if self.Map_Grid[neighbor[0]][neighbor[1]] == 0:
                   self.Map_Grid[neighbor[0]][neighbor[1]] = self.distance(neighbor,end) 
                # creating a list of the neighbors along with their corresponding wieght 
                distances.append((neighbor,self.Map_Grid[neighbor[0]][neighbor[1]]))
                
                #place onto min heap
                heapq.heappush(heap,(distances[-1][1],distances[-1][0]))
                
        # if the heap is empty that means no neighbor is traversable so there is no path possibe 
        if not heap:
            print("no path possible")
            exit()

        # take the top of the heap to get the neighbor with the smallest weight 
        else:     
            smallest = heapq.heappop(heap)
            # increment the smallest weight neighbor value by 1
            self.Map_Grid[smallest[1][0]][smallest[1][1]] = self.Map_Grid[smallest[1][0]][smallest[1][1]] + 1
            return smallest[1]
        
    """
    Name: isSamepoint()
    
    INPUT: 
      P1:   tuple 1 that will be compared  
      P2:   tuple 2 that will be compared 
    
    RETURN: 
      Bool:     True or False based on if the points are the same 
    
    DESCRIPTION:
        Compating P1 and P2 if they contain the same values 
    """ 
    def isSamepoint(self,P1:tuple,P2:tuple):
        if P1[0] == P2[0] and P1[1] == P2[1]:
            return True
        else:
            return False 
    """
    Name: isOutofBound()
    
    INPUT: 
      points:   tuple being checked if the coordinates are out of bound
    
    RETURN: 
      Bool:     True or False based on if the point is out of bound
    
    DESCRIPTION:
        checking the X and Y values to the dimensions of the grid to determine if the 
        point is within bounds 
    """    
    def isOutofBounds(self,points: tuple):
        
        if points[0] >= self.X_size or points[0] < 0:
            return True
        else:
            if points[1] >= self.Y_size or points[1] < 0:
                return True
            else:
                return False
    """
    Name: isTraversable()
    
    INPUT: 
      points:   tuple being checked if the coordinates are out of bound
    
    RETURN: 
      Bool:     True or False based on if the point is able to be considered as the next location 
    
    DESCRIPTION:
        checking if the point is out of bound if not then check if it contains a hazard 
        or if the the weight of the point is already passed the maximoum allowable
    """        
    def isTraversable(self,point:tuple[int,int]):
        if self.isOutofBounds(point):
          return False
        else:
            if self.Map_Grid[point[0]][point[1]] == -1:
                return False
            elif self.Map_Grid[point[0]][point[1]] >= self.Final_weight:
                return False
            else:
                return True
    """
    Name: generatePath()
    
    INPUT: 
      start:    tuple containing the start location
      end:      tuple containing the end location
    
    RETURN: 
      Bool:     True or False based on if the point is able to be considered as the next location 
    
    DESCRIPTION:
        checking if the point is out of bound if not then check if it contains a hazard 
        or if the the weight of the point is already passed the maximoum allowable
    """
    def generatePath(self,start:tuple,end:tuple):
        # initializing the start location as the start location
        current = start
        
        # determining the max allowed weight 
        self.Final_weight = self.distance(start,end)+2
        
        # where the path is stored
        path = []
        
        # adding the starting point to the path
        path.append(current)
        
        # while the current is not equal to the end point
        while not self.isSamepoint(current,end):
            
            # determining the neighbor with the smallest weight
            next = self.smallestNeighborsdistance(current,end)
            
            # adding that neighbor to the path 
            path.append(next)
            
            # updating position 
            current = next
        # updating the finalPath 
        self.Final_path = path
        return path
    """
    Name: cleanPath()
    
    INPUT: 
      start:    tuple containing the start location
    
    RETURN: 
      cleanPath:     the optimized path
    
    DESCRIPTION:
        This function will take the path generated then clean it by removing any duplicate points 
        then reruning the same path generation process but on considering the points that are in the path
    """
    def cleanPath(self,start:tuple[int,int]):
        #initialize necessary variables
        no_dups = []
        seen = set()
        n = 0
        neighbors = []
        cleaned_path = []
        heap = []
        
        # removing all duplicates but maintaining the order of the points 
        for tups in reversed(self.Final_path):
            if tups not in seen:
                no_dups.append(tups)
                seen.add(tups)
        # checking where the start value is in the list
        n = no_dups.index(start)
        
        #if the start is not at the end of the list then slice the list to remove all the points after the end point
        if n != len(no_dups):
            no_dups = no_dups[0:n+1]
            
        # perform path generation but only consider points that are currently in the path
        current = no_dups[0]
        cleaned_path.append(current)
        while not self.isSamepoint(current,start):
            #finding the neighbors in case there ae multiple points neighboring the current
            for indexes in self.neighbor_index:
                temp = (current[0]+indexes[0],current[1]+indexes[1])
                if temp in no_dups[no_dups.index(current):]:
                    neighbors.append(temp)

            # if one of the multiple neighbor is the start then always pick the start 
            if start in neighbors:
                n = neighbors.index(start)
                cleaned_path.append(neighbors[n])
                current = neighbors[n]
                neighbors.clear()
            
            # if there is only one neighbor just pick that neighbor
            elif len(neighbors) == 1:
                cleaned_path.append(neighbors[0])
                current = neighbors[0]
                neighbors.clear()
                
            # if there is more than one neighbor then pick the neighbor with the smallest weight
            elif len(neighbors) > 1:
                for tups in neighbors:
                    heapq.heappush(heap,(tups,self.Map_Grid[0][tups[0]][tups[1]]))
                next = heapq.heappop(heap)
                cleaned_path.append(next)
                current = next
                neighbors.clear() 
        path =  cleaned_path[::-1]
        return path
    """
    Name: placePathonMap()
    
    INPUT: 
      N/A
    
    RETURN: 
      N/A
    
    DESCRIPTION:
        Representing the path on the map by setting their locations to 2
    """
    def placePathonMap(self):
        for points in self.Final_path:
            self.Map_Grid[points[0]][points[1]] = 2
        
        
## MAIN DRIVER
#finalGrid = Grid(110,70,-5450,-6550,-9750,-10450)
#dStar = DstarKinda(finalGrid)
#start = (88, 36)
#end = (69,27)
#dStar.generatePath(start, end)
#path = dStar.cleanPath(start)
#newpath = path[::-1]
#print(newpath)

